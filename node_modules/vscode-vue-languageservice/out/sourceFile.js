"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSourceFile = void 0;
const shared = require("@volar/shared");
const reactivity_1 = require("@vue/reactivity");
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const refSugarRanges_1 = require("./parsers/refSugarRanges");
const useSfcEntryForTemplateLs_1 = require("./use/useSfcEntryForTemplateLs");
const useSfcJsons_1 = require("./use/useSfcJsons");
const useSfcScript_1 = require("./use/useSfcScript");
const useSfcScriptGen_1 = require("./use/useSfcScriptGen");
const useSfcStyles_1 = require("./use/useSfcStyles");
const useSfcTemplate_1 = require("./use/useSfcTemplate");
const useSfcTemplateCompileResult_1 = require("./use/useSfcTemplateCompileResult");
const useSfcTemplateScript_1 = require("./use/useSfcTemplateScript");
const string_1 = require("./utils/string");
const untrack_1 = require("./utils/untrack");
function createSourceFile(_document, context) {
    // refs
    const content = reactivity_1.ref(_document.getText());
    const version = reactivity_1.ref(_document.version);
    const descriptor = reactivity_1.reactive({
        template: null,
        script: null,
        scriptSetup: null,
        styles: [],
        customBlocks: [],
    });
    const lastUpdated = {
        template: false,
        script: false,
        scriptSetup: false,
    };
    const templateScriptData = reactivity_1.reactive({
        projectVersion: undefined,
        context: [],
        contextItems: [],
        components: [],
        componentItems: [],
        props: [],
        setupReturns: [],
    });
    // computeds
    const document = reactivity_1.computed(() => vscode_languageserver_textdocument_1.TextDocument.create(_document.uri, _document.languageId, version.value, content.value));
    const vueHtmlDocument = reactivity_1.computed(() => context.htmlLs.parseHTMLDocument(document.value));
    // use
    const sfcStyles = useSfcStyles_1.useSfcStyles(context, untrack_1.untrack(() => document.value), reactivity_1.computed(() => descriptor.styles));
    const sfcJsons = useSfcJsons_1.useSfcJsons(untrack_1.untrack(() => document.value), reactivity_1.computed(() => descriptor.customBlocks), context);
    const sfcTemplate = useSfcTemplate_1.useSfcTemplate(untrack_1.untrack(() => document.value), reactivity_1.computed(() => descriptor.template), context);
    const sfcTemplateData = reactivity_1.computed(() => {
        if (sfcTemplate.pugDocument.value) {
            const pugDoc = sfcTemplate.pugDocument.value;
            return {
                sourceLang: 'pug',
                html: pugDoc.htmlCode,
                htmlTextDocument: pugDoc.htmlTextDocument,
                htmlToTemplate: (htmlStart, htmlEnd) => {
                    const pugRange = pugDoc.sourceMap.getSourceRange2(htmlStart, htmlEnd);
                    if (pugRange) {
                        return pugRange.start;
                    }
                },
            };
        }
        if (descriptor.template && sfcTemplate.textDocument.value) {
            return {
                sourceLang: 'html',
                html: descriptor.template.content,
                htmlTextDocument: sfcTemplate.textDocument.value,
                htmlToTemplate: (htmlStart, _) => htmlStart,
            };
        }
    });
    const sfcTemplateCompileResult = useSfcTemplateCompileResult_1.useSfcTemplateCompileResult(reactivity_1.computed(() => { var _a; return (_a = sfcTemplateData.value) === null || _a === void 0 ? void 0 : _a.htmlTextDocument; }), context.isVue2Mode);
    const sfcScript = useSfcScript_1.useSfcScript(untrack_1.untrack(() => document.value), reactivity_1.computed(() => descriptor.script), context.modules.typescript);
    const sfcScriptSetup = useSfcScript_1.useSfcScript(untrack_1.untrack(() => document.value), reactivity_1.computed(() => descriptor.scriptSetup), context.modules.typescript);
    const sfcScriptForTemplateLs = useSfcScriptGen_1.useSfcScriptGen('template', context.modules.typescript, document, reactivity_1.computed(() => descriptor.script), reactivity_1.computed(() => descriptor.scriptSetup), reactivity_1.computed(() => sfcScript.ast.value), reactivity_1.computed(() => sfcScriptSetup.ast.value), sfcTemplateCompileResult, reactivity_1.computed(() => sfcStyles.textDocuments.value));
    const sfcScriptForScriptLs = useSfcScriptGen_1.useSfcScriptGen('script', context.modules.typescript, document, reactivity_1.computed(() => descriptor.script), reactivity_1.computed(() => descriptor.scriptSetup), reactivity_1.computed(() => sfcScript.ast.value), reactivity_1.computed(() => sfcScriptSetup.ast.value), sfcTemplateCompileResult, reactivity_1.computed(() => sfcStyles.textDocuments.value));
    const sfcEntryForTemplateLs = useSfcEntryForTemplateLs_1.useSfcEntryForTemplateLs(untrack_1.untrack(() => document.value), reactivity_1.computed(() => descriptor.script), reactivity_1.computed(() => descriptor.scriptSetup), reactivity_1.computed(() => descriptor.template), reactivity_1.computed(() => !!sfcScriptForTemplateLs.textDocumentTs.value));
    const sfcTemplateScript = useSfcTemplateScript_1.useSfcTemplateScript(untrack_1.untrack(() => document.value), reactivity_1.computed(() => descriptor.template), reactivity_1.computed(() => descriptor.styles), templateScriptData, sfcStyles.textDocuments, sfcStyles.sourceMaps, sfcTemplateData, sfcTemplateCompileResult, reactivity_1.computed(() => sfcStyles.textDocuments.value), sfcScriptForScriptLs.lang, context);
    const sfcRefSugarRanges = reactivity_1.computed(() => (sfcScriptSetup.ast.value ? {
        refs: refSugarRanges_1.parseRefSugarDeclarationRanges(context.modules.typescript, sfcScriptSetup.ast.value, ['$ref', '$computed', '$shallowRef', '$fromRefs']),
        raws: refSugarRanges_1.parseRefSugarCallRanges(context.modules.typescript, sfcScriptSetup.ast.value, ['$raw', '$fromRefs']),
    } : undefined));
    // getters
    const cssLsDocuments = reactivity_1.computed(() => [
        sfcTemplateScript.cssTextDocument.value,
        ...sfcStyles.textDocuments.value,
    ].filter(shared.notEmpty));
    const cssLsSourceMaps = reactivity_1.computed(() => [
        sfcTemplateScript.cssSourceMap.value,
        ...sfcStyles.sourceMaps.value,
    ].filter(shared.notEmpty));
    const templateLsSourceMaps = reactivity_1.computed(() => [
        sfcScriptForTemplateLs.sourceMap.value,
        sfcTemplateScript.sourceMap.value,
        sfcEntryForTemplateLs.sourceMap.value,
    ].filter(shared.notEmpty));
    const scriptLsSourceMaps = reactivity_1.computed(() => [
        sfcScriptForScriptLs.sourceMap.value,
    ].filter(shared.notEmpty));
    const templateLsDocuments = reactivity_1.computed(() => [
        sfcEntryForTemplateLs.textDocument.value,
        sfcScriptForTemplateLs.textDocument.value,
        sfcScriptForTemplateLs.textDocumentTs.value,
        sfcTemplateScript.textDocument.value,
    ].filter(shared.notEmpty));
    const scriptLsDocuments = reactivity_1.computed(() => [
        sfcScriptForScriptLs.textDocument.value,
    ].filter(shared.notEmpty));
    const tsSourceMaps = reactivity_1.computed(() => [
        sfcScriptForScriptLs.sourceMap.value,
        ...templateLsSourceMaps.value,
    ]);
    const templateLsTeleports = reactivity_1.computed(() => [
        sfcTemplateScript.teleportSourceMap.value,
        sfcScriptForTemplateLs.teleportSourceMap.value,
    ].filter(shared.notEmpty));
    update(_document);
    return {
        uri: _document.uri,
        getTemplateTagNames: untrack_1.untrack(() => { var _a; return (_a = sfcTemplateScript.templateCodeGens.value) === null || _a === void 0 ? void 0 : _a.tagNames; }),
        getTemplateAttrNames: untrack_1.untrack(() => { var _a; return (_a = sfcTemplateScript.templateCodeGens.value) === null || _a === void 0 ? void 0 : _a.attrNames; }),
        getTextDocument: untrack_1.untrack(() => document.value),
        getTemplateScriptDocument: untrack_1.untrack(() => sfcTemplateScript.textDocument.value),
        update: untrack_1.untrack(update),
        updateTemplateScript: untrack_1.untrack(updateTemplateScript),
        getScriptTsDocument: untrack_1.untrack(() => sfcScriptForScriptLs.textDocument.value),
        getScriptTsSourceMap: untrack_1.untrack(() => sfcScriptForScriptLs.sourceMap.value),
        getTsSourceMaps: untrack_1.untrack(() => tsSourceMaps.value),
        getCssSourceMaps: untrack_1.untrack(() => cssLsSourceMaps.value),
        getJsonSourceMaps: untrack_1.untrack(() => sfcJsons.sourceMaps.value),
        getHtmlSourceMaps: untrack_1.untrack(() => sfcTemplate.htmlSourceMap.value ? [sfcTemplate.htmlSourceMap.value] : []),
        getPugSourceMaps: untrack_1.untrack(() => sfcTemplate.pugSourceMap.value ? [sfcTemplate.pugSourceMap.value] : []),
        getTemplateScriptData: untrack_1.untrack(() => templateScriptData),
        getDescriptor: untrack_1.untrack(() => descriptor),
        getScriptAst: untrack_1.untrack(() => sfcScript.ast.value),
        getScriptSetupAst: untrack_1.untrack(() => sfcScriptSetup.ast.value),
        getVueHtmlDocument: untrack_1.untrack(() => vueHtmlDocument.value),
        getScriptSetupData: untrack_1.untrack(() => sfcScriptForTemplateLs.scriptSetupRanges.value),
        docLsScripts: untrack_1.untrack(() => ({
            documents: [sfcScript.textDocument.value, sfcScriptSetup.textDocument.value].filter(shared.notEmpty),
            sourceMaps: [sfcScript.sourceMap.value, sfcScriptSetup.sourceMap.value].filter(shared.notEmpty),
        })),
        getTemplateFormattingScript: untrack_1.untrack(() => ({
            document: sfcTemplateScript.textDocumentForFormatting.value,
            sourceMap: sfcTemplateScript.sourceMapForFormatting.value,
        })),
        getSfcRefSugarRanges: untrack_1.untrack(() => sfcRefSugarRanges.value),
        refs: {
            document,
            descriptor,
            lastUpdated,
            sfcJsons,
            sfcTemplate,
            sfcTemplateData,
            sfcTemplateCompileResult,
            sfcTemplateScript,
            sfcScriptForScriptLs,
            sfcScriptForTemplateLs,
            templateScriptData,
            cssLsDocuments,
            cssLsSourceMaps,
            scriptLsDocuments,
            scriptLsSourceMaps,
            templateLsDocuments,
            templateLsSourceMaps,
            templateLsTeleports,
        },
    };
    function update(newDocument) {
        var _a, _b;
        const scriptLang_1 = sfcScriptForScriptLs.textDocument.value.languageId;
        const scriptText_1 = sfcScriptForScriptLs.textDocument.value.getText();
        const templateScriptVersion_1 = (_a = sfcTemplateScript.textDocument.value) === null || _a === void 0 ? void 0 : _a.version;
        content.value = newDocument.getText();
        version.value = newDocument.version;
        const parsedSfc = shared.parseSfc(newDocument.getText(), vueHtmlDocument.value);
        updateTemplate(parsedSfc['template']);
        updateScript(parsedSfc['script']);
        updateScriptSetup(parsedSfc['scriptSetup']);
        updateStyles(parsedSfc['styles']);
        updateCustomBlocks(parsedSfc['customBlocks']);
        sfcTemplateScript.update(); // TODO
        const scriptLang_2 = sfcScriptForScriptLs.textDocument.value.languageId;
        const scriptText_2 = sfcScriptForScriptLs.textDocument.value.getText();
        const templateScriptVersion_2 = (_b = sfcTemplateScript.textDocument.value) === null || _b === void 0 ? void 0 : _b.version;
        return {
            scriptContentUpdated: lastUpdated.script || lastUpdated.scriptSetup,
            scriptUpdated: scriptLang_1 !== scriptLang_2 || scriptText_1 !== scriptText_2,
            templateScriptUpdated: templateScriptVersion_1 !== templateScriptVersion_2,
        };
        function updateTemplate(newData) {
            var _a, _b;
            lastUpdated.template = ((_a = descriptor.template) === null || _a === void 0 ? void 0 : _a.lang) !== (newData === null || newData === void 0 ? void 0 : newData.lang)
                || ((_b = descriptor.template) === null || _b === void 0 ? void 0 : _b.content) !== (newData === null || newData === void 0 ? void 0 : newData.content);
            if (descriptor.template && newData) {
                updateBlock(descriptor.template, newData);
            }
            else {
                descriptor.template = newData;
            }
        }
        function updateScript(newData) {
            var _a, _b;
            lastUpdated.script = ((_a = descriptor.script) === null || _a === void 0 ? void 0 : _a.lang) !== (newData === null || newData === void 0 ? void 0 : newData.lang)
                || ((_b = descriptor.script) === null || _b === void 0 ? void 0 : _b.content) !== (newData === null || newData === void 0 ? void 0 : newData.content);
            if (descriptor.script && newData) {
                updateBlock(descriptor.script, newData);
            }
            else {
                descriptor.script = newData;
            }
        }
        function updateScriptSetup(newData) {
            var _a, _b;
            lastUpdated.scriptSetup = ((_a = descriptor.scriptSetup) === null || _a === void 0 ? void 0 : _a.lang) !== (newData === null || newData === void 0 ? void 0 : newData.lang)
                || ((_b = descriptor.scriptSetup) === null || _b === void 0 ? void 0 : _b.content) !== (newData === null || newData === void 0 ? void 0 : newData.content);
            if (descriptor.scriptSetup && newData) {
                updateBlock(descriptor.scriptSetup, newData);
            }
            else {
                descriptor.scriptSetup = newData;
            }
        }
        function updateStyles(newDataArr) {
            for (let i = 0; i < newDataArr.length; i++) {
                const newData = newDataArr[i];
                if (descriptor.styles.length > i) {
                    updateBlock(descriptor.styles[i], newData);
                }
                else {
                    descriptor.styles.push(newData);
                }
            }
            while (descriptor.styles.length > newDataArr.length) {
                descriptor.styles.pop();
            }
        }
        function updateCustomBlocks(newDataArr) {
            for (let i = 0; i < newDataArr.length; i++) {
                const newData = newDataArr[i];
                if (descriptor.customBlocks.length > i) {
                    updateBlock(descriptor.customBlocks[i], newData);
                }
                else {
                    descriptor.customBlocks.push(newData);
                }
            }
            while (descriptor.customBlocks.length > newDataArr.length) {
                descriptor.customBlocks.pop();
            }
        }
        function updateBlock(oldBlock, newBlock) {
            for (let key in newBlock) {
                oldBlock[key] = newBlock[key];
            }
        }
    }
    function updateTemplateScript(templateTsLs) {
        var _a, _b;
        const newVersion = (_b = (_a = templateTsLs.__internal__.host).getProjectVersion) === null || _b === void 0 ? void 0 : _b.call(_a);
        if (templateScriptData.projectVersion === newVersion) {
            return false;
        }
        templateScriptData.projectVersion = newVersion;
        const doc = sfcEntryForTemplateLs.textDocument.value;
        const docText = doc.getText();
        const context = docText.indexOf(string_1.SearchTexts.Context) >= 0 ? templateTsLs.__internal__.doCompleteSync(doc.uri, doc.positionAt(docText.indexOf(string_1.SearchTexts.Context))) : [];
        let components = docText.indexOf(string_1.SearchTexts.Components) >= 0 ? templateTsLs.__internal__.doCompleteSync(doc.uri, doc.positionAt(docText.indexOf(string_1.SearchTexts.Components))) : [];
        const props = docText.indexOf(string_1.SearchTexts.Props) >= 0 ? templateTsLs.__internal__.doCompleteSync(doc.uri, doc.positionAt(docText.indexOf(string_1.SearchTexts.Props))) : [];
        const setupReturns = docText.indexOf(string_1.SearchTexts.SetupReturns) >= 0 ? templateTsLs.__internal__.doCompleteSync(doc.uri, doc.positionAt(docText.indexOf(string_1.SearchTexts.SetupReturns))) : [];
        components = components.filter(entry => {
            const name = entry.data.name;
            return name.indexOf('$') === -1 && !name.startsWith('_');
        });
        const contextNames = context.map(entry => entry.data.name);
        const componentNames = components.map(entry => entry.data.name);
        const propNames = props.map(entry => entry.data.name);
        const setupReturnNames = setupReturns.map(entry => entry.data.name);
        let dirty = false;
        if (!shared.eqSet(new Set(contextNames), new Set(templateScriptData.context))) {
            templateScriptData.context = contextNames;
            templateScriptData.contextItems = context;
            dirty = true;
        }
        if (!shared.eqSet(new Set(componentNames), new Set(templateScriptData.components))) {
            templateScriptData.components = componentNames;
            templateScriptData.componentItems = components;
            dirty = true;
        }
        if (!shared.eqSet(new Set(propNames), new Set(templateScriptData.props))) {
            templateScriptData.props = propNames;
            dirty = true;
        }
        if (!shared.eqSet(new Set(setupReturnNames), new Set(templateScriptData.setupReturns))) {
            templateScriptData.setupReturns = setupReturnNames;
            dirty = true;
        }
        if (dirty) {
            sfcTemplateScript.update(); // TODO
        }
        return dirty;
    }
}
exports.createSourceFile = createSourceFile;
//# sourceMappingURL=sourceFile.js.map